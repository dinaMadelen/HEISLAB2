----------------------
6e9c22cf - VÃ¥r gruppe
2be0c418 - Kristoffer
c7028f29 - Dina
0c25976e - Svein Thore
----------------------

-------
Outline
-------
- Score
    Give a score from 5 to 9
        5 - Can't be fixed. Have to start over, but try smaller projects first.
        6 - Not reasonable. Have to start over, probably will be improved.
        7 - Hard to read, can glimpse design. Tidying could make reasonable.
        8 - Reasonable code, could deteriorate if larger project.
        9 - Manageble project, bug fixes and feature adding won't break code.

- Structure
    hash1
    score1
    bullet point 1
    bulletpoint 2
    (other plaintext)

- Suggested criteria
    Main function/top-level entry points
        - Components
        - Dependencies
        - Functionality
    Individual modules from "outside"
        - Coherence
        - Completeness
    Individual modules from "inside"
        - State
        - Functions
        - Understandability
    Interactions between modules
        - Traceability
        - Direction
    Details
        - Comments
        - Naming
    Whole
        - Gut-feeling
        - Feedback

    - Summarized
        Main
        Modules - outside
        Modules - inside
        Modules - interactions
        Details
        Whole


--------------
Feedback notes
--------------
- Readme
    Good readme file. Descriptive, nice outline of project.

- Main
    Understandable cli arg-parsing. Good code, easy to follow and seems very reasonable.
    - score: 9


--------
Feedback
--------
2be0c418
9
- The entry point code is well crafted. Just reading through main.rs alone paints a very clear picure of the things that are happening at the top-level. There are almost no comments in main.rs, but this is not even a problem because of how readable and clean the code is. The project also has a very descriptive and nice readme file that explains the high-level design of the project, and is very helpful to getting to know the codebase. However, since main.rs should be able to be used as a black box (take command line arguments and just work), i feel like there should be a short section early on, either in the readme or a comment in main.rs itself, that breifly describes how the program should be used. What arguments does it take? What does it do? Reading through the args struct gives information about the program args, but it doesn't say what the program does, and i should not have to start reading code to know what arguments to pass to a program.
- From a outside point of view, the choice of module Structure and naming (the interface in general) is good, and gives a clear indication of the functionality of the module. This makes it a lot easier to get up to speed on the codebase, and provides for seamless integration of potential new developers/collaborators.
- From a inside point of view the code has good usage of "modular" functions (smaller functions that call other smaller functions). The code is compact and readable, and despite this the number of small functions is held reasonably low. It could however benefit from a bit more modularity here and there, especially wrapping the handling of "things" inside handler functions. This would make the high-level thought behind the code easier to follow. Having the concrete handling of specific cases in a high-level of abstraction function ruins the readability of the code. If i want to know how a certain case is handled, i should just go to that function. All i need to know in the high-level function is that all cases are probed for and handled accordingly. 
- The details of the code are good. Names are very descriptive, and makes for easy reading. The commenting could be better in the lower-level code. Since the naming is so good, commenting is really not neccessary in the high-level of abstraction code. However in the lower levels, comments can make it easier to follow along, without always having to infer the purpose of some line of code.
- My gut feeling is that this group has handled the project well. The design seems thought through, and the code is well crafted. There could be made some improvements here and there, but this is just nitpicking and well within the capabilities of the group. The proposed improvements just consists of improving the separation of higher and lower level of abstraction code, and adding some comments in lower level code. This is not too hard, and the group could easily manage this. 
